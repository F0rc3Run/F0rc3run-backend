name: Find Clean WARP Endpoints via Dynamic Iran Proxy

on:
  workflow_dispatch:
  schedule:
    - cron: '0 */6 * * *'

jobs:
  scan-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Main Repo
        uses: actions/checkout@v4

      - name: Setup Go Environment
        uses: actions/setup-go@v5
        with:
          go-version: '1.21'

      - name: Install Dependencies & Build Scanner
        run: |
          sudo apt-get update && sudo apt-get install -y wget curl jq
          echo "Downloading sing-box client..."
          wget -O sing-box.tar.gz "https://github.com/SagerNet/sing-box/releases/download/v1.12.0/sing-box-1.12.0-linux-amd64.tar.gz"
          tar -xzf sing-box.tar.gz
          cp sing-box-1.12.0-linux-amd64/sing-box .
          chmod +x sing-box
          echo "Cloning and building the scanner from source..."
          git clone https://github.com/bia-pain-bache/BPB-Warp-Scanner.git scanner-source
          cd scanner-source
          go build -o ../scanner .
          cd ..
          chmod +x scanner
          echo "Scanner built successfully."

      - name: Find and Connect to a Working Iran Proxy
        id: proxy_connect
        run: |
          python3 -c "
          import os, sys, json, subprocess, time, urllib.parse, base64, re

          def create_vless_config(uri):
              try:
                  # Remove fragment if exists
                  uri = uri.split('#')[0]
                  parsed = urllib.parse.urlparse(uri)
                  params = urllib.parse.parse_qs(parsed.query)
                  
                  config = {
                      'type': 'vless',
                      'server': parsed.hostname,
                      'server_port': parsed.port,
                      'uuid': parsed.username,
                      'flow': params.get('flow', [''])[0] or None,
                      'packet_encoding': params.get('packetEncoding', [''])[0] or None
                  }
                  
                  # Handle transport
                  transport_type = params.get('type', ['tcp'])[0]
                  
                  if transport_type == 'tcp':
                      transport = {'type': 'tcp'}
                      header_type = params.get('headerType', ['none'])[0]
                      if header_type == 'http':
                          transport['header'] = {
                              'type': 'http',
                              'host': params.get('host', [''])[0].split(',') if params.get('host') else None,
                              'path': params.get('path', ['/'])[0]
                          }
                      config['transport'] = transport
                  
                  elif transport_type == 'ws':
                      config['transport'] = {
                          'type': 'ws',
                          'path': params.get('path', ['/'])[0],
                          'headers': {'Host': params.get('host', [''])[0]} if params.get('host') else None
                      }
                  
                  elif transport_type == 'grpc':
                      config['transport'] = {
                          'type': 'grpc',
                          'service_name': params.get('serviceName', [''])[0]
                      }
                  
                  # Handle TLS
                  security = params.get('security', ['none'])[0]
                  if security == 'tls':
                      config['tls'] = {
                          'enabled': True,
                          'server_name': params.get('sni', [''])[0] or parsed.hostname,
                          'insecure': True,
                          'alpn': params.get('alpn', [''])[0].split(',') if params.get('alpn') else None
                      }
                  
                  # Clean up None values
                  config = {k: v for k, v in config.items() if v is not None}
                  if 'transport' in config:
                      config['transport'] = {k: v for k, v in config['transport'].items() if v is not None}
                  
                  print(f'  -> Parsed VLESS: server={config[\"server\"]}:{config[\"server_port\"]}, transport={transport_type}')
                  return config
              except Exception as e:
                  print(f'  -> VLESS Parse Error: {e}')
                  return None

          def create_ss_config(uri):
              try:
                  # Remove fragment
                  uri_clean = uri.split('#')[0]
                  uri_body = uri_clean.replace('ss://', '')
                  
                  if '@' in uri_body:
                      # Format: method:password@server:port
                      creds_part, server_part = uri_body.split('@')
                      if ':' in creds_part:
                          method, password = creds_part.split(':', 1)
                      else:
                          # Base64 encoded credentials
                          decoded_creds = base64.b64decode(creds_part + '=' * (4 - len(creds_part) % 4)).decode('utf-8')
                          method, password = decoded_creds.split(':', 1)
                  else:
                      # Entire URI is base64 encoded
                      decoded = base64.b64decode(uri_body + '=' * (4 - len(uri_body) % 4)).decode('utf-8')
                      match = re.match(r'(.+?):(.+?)@(.+?):(\d+)', decoded)
                      if match:
                          method, password, server, server_port = match.groups()
                          server_part = f'{server}:{server_port}'
                      else:
                          raise ValueError('Invalid SS URI format')
                  
                  if '@' in uri_body:
                      server, server_port = server_part.split(':')
                  
                  config = {
                      'type': 'shadowsocks',
                      'server': server,
                      'server_port': int(server_port),
                      'method': method,
                      'password': password
                  }
                  print(f'  -> Parsed SS: server={config[\"server\"]}:{config[\"server_port\"]}, method={config[\"method\"]}')
                  return config
              except Exception as e:
                  print(f'  -> SS Parse Error: {e}')
                  return None

          def create_vmess_config(uri):
              try:
                  b64_body = uri.replace('vmess://', '')
                  padding = len(b64_body) % 4
                  if padding != 0:
                      b64_body += '=' * (4 - padding)
                  decoded_json = json.loads(base64.b64decode(b64_body).decode('utf-8'))
                  
                  config = {
                      'type': 'vmess',
                      'server': decoded_json.get('add'),
                      'server_port': int(decoded_json.get('port')),
                      'uuid': decoded_json.get('id'),
                      'alter_id': int(decoded_json.get('aid', 0)),
                      'security': decoded_json.get('scy', 'auto')
                  }
                  
                  # Handle transport
                  net = decoded_json.get('net', 'tcp')
                  if net == 'ws':
                      config['transport'] = {
                          'type': 'ws',
                          'path': decoded_json.get('path', '/'),
                          'headers': {'Host': decoded_json.get('host')} if decoded_json.get('host') else None
                      }
                  elif net == 'tcp':
                      config['transport'] = {'type': 'tcp'}
                  
                  # Handle TLS
                  if decoded_json.get('tls') == 'tls':
                      config['tls'] = {
                          'enabled': True,
                          'server_name': decoded_json.get('sni', decoded_json.get('add')),
                          'insecure': True
                      }
                  
                  print(f'  -> Parsed VMess: server={config[\"server\"]}:{config[\"server_port\"]}, uuid={config[\"uuid\"]}')
                  return config
              except Exception as e:
                  print(f'  -> VMess Parse Error: {e}')
                  return None

          print('Fetching proxy list from URL...')
          subprocess.run(['curl', '-s', '-o', 'ir_proxies.txt', 'https://raw.githubusercontent.com/F0rc3Run/F0rc3Run/refs/heads/main/splitted-by-country/IR.txt'])

          proxy_count = 0
          with open('ir_proxies.txt', 'r') as f:
              for line in f:
                  proxy_uri = line.strip()
                  if not proxy_uri or proxy_uri.startswith('//'):
                      continue
                  
                  proxy_count += 1
                  print(f'\\n--- Testing proxy #{proxy_count}: {proxy_uri[:80]}... ---')

                  outbound_config = None
                  if proxy_uri.startswith('vless://'):
                      print('Detected VLESS proxy')
                      outbound_config = create_vless_config(proxy_uri)
                  elif proxy_uri.startswith('ss://'):
                      print('Detected Shadowsocks proxy')
                      outbound_config = create_ss_config(proxy_uri)
                  elif proxy_uri.startswith('vmess://'):
                      print('Detected VMess proxy')
                      outbound_config = create_vmess_config(proxy_uri)
                  
                  if not outbound_config:
                      print('‚ùå FAILED: Could not parse proxy config. Skipping.')
                      continue

                  config = {
                      'log': {'level': 'error'},
                      'inbounds': [{
                          'type': 'socks',
                          'listen': '127.0.0.1',
                          'listen_port': 1080,
                          'sniff': True,
                          'sniff_override_destination': True
                      }],
                      'outbounds': [outbound_config]
                  }

                  with open('config.json', 'w') as cfg_file:
                      json.dump(config, cfg_file, indent=2)

                  process = subprocess.Popen(['./sing-box', 'run', '-c', 'config.json'], 
                                           stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                  time.sleep(5)

                  try:
                      # First test basic connectivity
                      test_result = subprocess.run(
                          ['timeout', '10', 'curl', '--socks5', '127.0.0.1:1080', '-s', '--max-time', '8', 'http://ip-api.com/json'],
                          capture_output=True, text=True
                      )
                      
                      if test_result.returncode == 0 and test_result.stdout:
                          response = json.loads(test_result.stdout)
                          country = response.get('country', 'Unknown')
                          ip = response.get('query', 'Unknown')
                          print(f'  -> Connected! IP: {ip}, Country: {country}')
                          
                          if country == 'Iran' or 'Iran' in country:
                              print(f'‚úÖ SUCCESS: Found working Iran proxy!')
                              print(f'  -> Server: {outbound_config.get(\"server\")}:{outbound_config.get(\"server_port\")}')
                              # Keep the process running
                              with open('proxy_pid.txt', 'w') as f:
                                  f.write(str(process.pid))
                              sys.exit(0)
                          else:
                              print(f'‚ùå FAILED: Proxy connected but from {country}, not Iran. Trying next...')
                      else:
                          print(f'‚ùå FAILED: Connection test failed. Return code: {test_result.returncode}')
                          if test_result.stderr:
                              print(f'  -> Error: {test_result.stderr.strip()}')
                  except subprocess.TimeoutExpired:
                      print('‚ùå FAILED: Connection timeout. Trying next...')
                  except json.JSONDecodeError:
                      print('‚ùå FAILED: Invalid response from IP check. Trying next...')
                  except Exception as e:
                      print(f'‚ùå FAILED: Unexpected error: {e}')
                  
                  process.terminate()
                  try:
                      process.wait(timeout=3)
                  except subprocess.TimeoutExpired:
                      process.kill()

          print('\\n::error::No working Iran proxy found in the list.')
          sys.exit(1)
          "

      - name: Run Scanner
        run: |
          echo "Starting the scan through the Iran proxy..."
          export ALL_PROXY=socks5://127.0.0.1:1080
          export HTTP_PROXY=socks5://127.0.0.1:1080
          export HTTPS_PROXY=socks5://127.0.0.1:1080
          printf "2\n1\n1\n1\n20" | ./scanner
          echo "Scan finished."

      - name: Convert Top 20 CSV results to JSON
        run: |
          python3 -c "
          import csv, json
          data = {'ipv4': [], 'ipv6': []}
          try:
              with open('result.csv', 'r') as f:
                  reader = csv.DictReader(f)
                  for row in reader:
                      endpoint = row.get('Endpoint', '').strip()
                      if not endpoint: continue
                      if '[' in endpoint and ']' in endpoint:
                          data['ipv6'].append(endpoint)
                      else:
                          data['ipv4'].append(endpoint)
              with open('results.json', 'w') as f:
                  json.dump(data, f, indent=2)
              print('Successfully converted endpoints to JSON.')
          except FileNotFoundError:
              print('Error: result.csv not found.')
              exit(1)
          "

      - name: Checkout public repository
        uses: actions/checkout@v4
        with:
          repository: F0rc3Run/free-warp-endpoints
          token: ${{ secrets.PAT }}
          path: 'public-repo'

      - name: Move result file to public repo
        run: mv results.json public-repo/results.json

      - name: Commit and Push to public repository
        run: |
          cd public-repo
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          if [[ -n $(git status -s) ]]; then
            git add results.json
            git commit -m "Automated: Update top 20 endpoints"
            git push
          else
            echo "No changes to commit."
          fi
